<html> 
    <head> 
        <title>Frogger</title> 
        <style> body { margin: 0; } canvas { width: 100%; height: 100% } </style> 
    </head> 

    <body> 
        <script src="three.js"></script> 
        <script src="DynamicObj/Bus.js"></script>
        <script src="DynamicObj/Car.js"></script>
        <script src="DynamicObj/Frog.js"></script>
        <script src="StaticObj/River.js"></script>
        <script src="StaticObj/Road.js"></script>
        <script src="StaticObj/Riversides.js"></script>
        <script src="StaticObj/Roadside.js"></script>
        <script src="DynamicObj/TimberLog.js"></script>
        <script src="DynamicObj/Turtle.js"></script>
        <script src="StaticObj/Tunnels.js"></script>
        <script src="StaticObj/Tree.js"></script>
        <script src="DynamicObj/Particle.js"></script>

        <!-- Shaders -->
        <script type="x-shader/x-vertex" id="vertexShader">

            varying vec3 vNormal;
            varying vec3 eye;
            varying vec2 vUv;

            uniform vec3 night;
            varying vec3 nightV;

            uniform vec3 spotDir;
            varying vec3 spotDirV;
            uniform vec3 spotPos;
            varying vec3 spotPosV;

            uniform float billboard;
            uniform float life;
            varying float lifeP;

            void main() {

            vNormal = normal;
            vUv = uv;
            nightV = night;
            spotDirV = spotDir;
            lifeP = life;

            mat4 viewModel = modelViewMatrix;

            vec4 eyeAux = -(modelMatrix * vec4( position, 1.0 ));
            eye = eyeAux.xyz;
            spotPosV = spotPos - eyeAux.xyz;

            if(billboard == 1.0){
            viewModel[0].xyz = vec3(1.0, 0.0, 0.0);
            viewModel[1].xyz = vec3(0.0, 1.0, 0.0);
            viewModel[2].xyz = vec3(0.0, 0.0, 1.0);

            gl_Position = projectionMatrix * viewModel * vec4( position, 1.0 );
            }
            else{
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }

            }

        </script>

        <script type="x-shader/x-fragment" id="fragmentShader">


            uniform vec3 ambient;
            uniform vec3 diffuse;
            uniform vec3 spec;
            uniform float shininess;
            varying vec3 night;
            uniform float texMode;
            varying float lifeP;
            uniform sampler2D texture1;

            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 eye;
            varying vec3 nightV;
            varying vec3 spotDirV;
            varying vec3 spotPosV;
            
            void main() {

                vec4 sumDir = vec4(0.0, 0.0, 0.0, 0.0);
                vec4 sumSpot = vec4(0.0, 0.0, 0.0, 0.0);
                vec3 light = vec3(0.0, 0.0, 1.0);
                light = normalize(light);
                vec3 e = normalize(eye);
                
                vec3 vAux = normalize(vNormal);
                vec4 texel;
                vec4 texLight;

               
                // Directional Light 
                float dProd = max(0.0, dot(vAux, light));
                vec3 l_diff = dProd * diffuse;
                vec3 l_spec = vec3(0.0, 0.0, 0.0);

                if(dProd > 0.0){
                vec3 h = normalize(e + light);
                float int_spec = max(dot(h,vAux), 0.0);
                l_spec = spec * max( pow(int_spec, shininess), 0.0);
    
                if(texMode == 1.0){
                    texel = texture2D(texture1, vUv);
                    texLight = texel * dProd + vec4(l_spec, 1.0);
                    sumDir = texLight * nightV.x;        
                }
                else{
                    sumDir = vec4(l_diff + l_spec, 1.0) * nightV.x;
                }
                         
                }
                
                // SpotLight
                
                vec3 sp = normalize(spotPosV);
                vec3 sd = normalize(spotDirV);
                vec3 spec_dir = vec3(0.0, 0.0, 0.0);
		float iS = 0.0;
		if(dot(sd, sp) > 0.7) {
			iS = max(dot(vAux,sp), 0.0);
			if(iS > 0.0) {
				vec3 h = normalize(sp + e);
				float intSpecSpot = max(dot(h, vAux), 0.0);
				spec_dir = spec * pow(intSpecSpot, shininess);

				if(texMode == 1.0)
				{
                                    texel = texture2D(texture1, vUv);
                                    texLight = texel * iS + vec4(spec_dir, 1.0);
                                    sumSpot = texLight * nightV.z;    
				}
				else
				{
                                    sumSpot = vec4(iS*diffuse + spec_dir, 1.0) * nightV.z;
				}
			}
		}
                
                  
                if(texMode == 1.0){
                   
                    if(texel.a < 0.3)
                        discard;
                     if(lifeP > 0.0){
                        texel.a = lifeP;
                    }
                    
                    gl_FragColor = max(sumDir + sumSpot, texel * 0.5);
                }
                
                else{
                    vec3 color = max(ambient, sumDir.rgb + sumSpot.rgb);
                    gl_FragColor= vec4(color, 1.0);
                }
            }
            

        </script>

        <script>

///////////////////////////////////////////////////////////////////////////////// Main Variables
var scene = new THREE.Scene();
var camera;
var camType = 1;
var nightMode = new THREE.Vector3(1.0, 0.0, 0.0);

var sDir = new THREE.Vector3(0.0, 1.0, 0.0);
var sPos = new THREE.Vector3(0.0, 7.5, 1.25);

var didLeft = 0.0;
var didRight = 0.0;
var didDown = 0.0;

// Shader Association
var vertexShader = document.getElementById('vertexShader').textContent;
var fragmentShader = document.getElementById('fragmentShader').textContent;

var renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

///////////////////////////////////////////////////////////////////////////////// Camera Functions

function updateCamera() {
    if (camType === 1) {
        camera = new THREE.OrthographicCamera(window.innerWidth / -100, window.innerWidth / 100,
                window.innerHeight / 100, window.innerHeight / -100, -500, 1000);
        camera.position.z = 9.0;
    }
    else if (camType === 2) {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 9.0;
    }
    else {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(frog[0].position.x, frog[0].position.y - 1, frog[0].position.z + 1);
        camera.lookAt(frog[1].position);
    }

}

///////////////////////////////////////////////////////////////// Keyboard Callbacks

document.addEventListener('keydown', onDocumentKeyDown, false);
function onDocumentKeyDown(event) {
    event = event || window.event;
    var keycode = event.keyCode;
    switch (keycode) {
        case 37 : //left arrow
            left = true;
            sDir.x = -1.0;
            sDir.y = 0.5;
            break;
        case 38 : // up arrow 
            up = true;
            sDir.x = 0.0;
            sDir.y = 0.5;
            break;
        case 39 : // right arrow
            right = true;
            sDir.x = 1.0;
            sDir.y = 0.5;
            break;
        case 40 : //down arrow
            down = true;
            sDir.x = 0.0;
            sDir.y = -1.0;
            break;
        case 49 : //1 button ortogonal camera 
            camType = 1;
            break;
        case 50 : //2 button perspective camera
            camType = 2;
            break;
        case 51 : //3 button 3rd person camera
            camType = 3;
            break;
        case 76:
            initParticles();
            break;
        case 78 :
            if (nightMode.x === 1.0) {
                nightMode.x = 0.0;
                nightMode.z = 1.0;
            }
            else {
                nightMode.x = 1.0;
                nightMode.z = 0.0;
            }
            break;

    }
    document.addEventListener('keyup', onDocumentKeyUp, false);
}

function onDocumentKeyUp(event) {
    event = event || window.event;
    var keycode = event.keyCode;
    switch (keycode) {
        case 37 : //left arrow
            left = false;
            /*var mytext = "Hello again";
             document.write(mytext);*/
            break;
        case 38 : // up arrow 
            up = false;
            break;
        case 39 : // right arrow
            right = false;
            break;
        case 40 : //down arrow
            down = false;
            break;
    }
}

/*var mouseDown = false;
 var lastMouseX = null;
 var lastMouseY = null;
 
 function handleMouseDown(event) {
 mouseDown = true;
 lastMouseX = event.clientX;
 lastMouseY = event.clientY;
 }
 
 function handleMouseUp(event) {
 mouseDown = false;
 }
 
 function handleMouseMove(event) {
 if (!mouseDown) return;
 var newX = event.clientX;
 var newY = event.clientY;
 var deltaX = newX - lastMouseX;
 var deltaY = newY - lastMouseY;
 lastMouseX = newX;
 lastMouseY = newY;
 
 }
 */

function collision() {

    frogBoundBox();

    var auxCars = allCars();
    var auxBus = allBus();
    var auxLogs = allLogs();
    var auxTurtles = allTurtles();

    var bbCar;
    var bbBus;
    var bbLog;
    var bbTurtle;

    var collideBottom = 0.0;
    var collideUpL = 0.0;
    var collideUpT = 0.0;

    var frogBB = frogBoundBox();

    for (i = 0; i < auxCars.length; i += 5) {
        bbCar = carBoundBox(auxCars[i]);
        if (bbCar.isIntersectionBox(frogBB))
            collideBottom = 1.0;
    }

    for (i = 0; i < auxBus.length; i += 5) {
        bbBus = busBoundBox(auxBus[i]);
        if (bbBus.isIntersectionBox(frogBB))
            collideBottom = 1.0;
    }

    for (i = 0; i < auxLogs.length; i++) {
        bbLog = logBoundBox(auxLogs[i]);
        if (bbLog.isIntersectionBox(frogBB))
            collideUpL = 1.0;
    }

    for (i = 0; i < auxTurtles.length; i++) {
        bbTurtle = turtleBoundBox(auxTurtles[i]);
        if (bbTurtle.isIntersectionBox(frogBB))
            collideUpT = 1.0;
    }

    if (collideBottom === 1.0)
        initialPosition();

    if (frog[0].position.y > 0.7 && frog[0].position.y < 4.5) {
        if (collideUpL === 1.0)
            setPosition(0.04);
        else if (collideUpT === 1.0)
            setPosition(0.01);
        else
            initialPosition();

    }

}



        </script>

        <script>

            // Create Objects
            var road = new Road();
            var roadside = new RoadSide();
            var riversides = new RiverSides();
            var tunnels = new Tunnels();

            var frogger = new Frog();

            var cars = new Cars();
            var buses = new Bus();
            var logs = new TimberLog();
            var tortoises = new Turtles();
            var tree = new Tree();
            var firework = new Particle();
            var river = new River();

            var timer = setInterval("iterate()", 50);

            // Render Scene
            var render = function () {
                updateCamera();

                updateFrog();
                updateBus();
                updateCars();
                updateLogs();
                updateTurtles();

                collision();

                requestAnimationFrame(render);
                renderer.render(scene, camera);
            };

            render();
        </script> 
    </body> 
</html>